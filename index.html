<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<title>Bitcoin Pac â€” Eat Dollars (Easy Edition)</title>
<style>
  :root{
    --bg:#0b0b0b;
    --card:#0f0f0f;
    --accent:#ff8a00; /* orange */
    --muted:#bdbdbd;
    --dollar:#22c55e;
    --ghost:#e83a3a;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--muted);font-family:Inter,system-ui,Segoe UI,Roboto,Arial;}
  #gameWrap{max-width:960px;margin:18px auto;padding:12px;background:linear-gradient(180deg,#0d0d0d,#0a0a0a);border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,0.6);}
  header{display:flex;align-items:center;gap:12px;padding:8px 12px;border-bottom:1px solid rgba(255,255,255,0.05)}
  h1{margin:0;font-size:18px;color:var(--accent)}
  #hud{display:flex;gap:12px;align-items:center;margin-left:auto;font-size:14px;color:var(--muted)}
  .badge{padding:2px 8px;border:1px solid rgba(255,255,255,0.08);border-radius:999px}
  canvas{display:block;margin:12px auto;background:#050505;border-radius:6px;border:4px solid #070707;}
  .controls{display:flex;gap:8px;justify-content:center;padding:8px}
  .btn{background:transparent;border:1px solid rgba(255,255,255,0.08);padding:6px 10px;border-radius:6px;color:var(--muted);cursor:pointer}
  .small{font-size:13px;color:#999}
  #overlayTouch{position:relative;max-width:680px;margin:0 auto}
  .directionPad{position:absolute;left:10px;bottom:10px;width:150px;height:150px;display:flex;align-items:center;justify-content:center;pointer-events:none;}
  .pad-btn {
  position:absolute;
  width:70px;   /* bigger touch target */
  height:70px;
  border-radius:12px;
  background:rgba(255,255,255,0.04);
  display:flex;
  align-items:center;
  justify-content:center;
  color:var(--muted);

  /* mobile zoom fixes */
  font-size:0;             /* prevents auto-zoom on tap */
  line-height:0;
  pointer-events:auto;
  user-select:none;
  touch-action:manipulation; /* disables double-tap zoom */
}

.pad-btn::after {
  font-size:26px;           /* visible arrow size */
  line-height:1;
  content:attr(data-dir-symbol);
}

.up{top:8px;left:48px}
.down{bottom:8px;left:48px}
.left{left:8px;top:48px}
.right{right:8px;top:48px}
footer{font-size:12px;color:#8f8f8f;padding:8px;text-align:center}

@media (max-width:600px){
  canvas{width:100%}
  .directionPad{transform:scale(0.9)}
}
</style>
</head>
<body>
<div id="gameWrap">
  <header>
    <h1>Bitcoin Pac â€” Eat Dollars</h1>
    <div id="hud">
      <div id="score" class="badge">Score: 0</div>
      <div id="lives" class="badge">Lives: 5</div>
      <div id="level" class="badge">Level: 1</div>
      <div id="status" class="badge">â€”</div>
      <button class="btn" id="restart">Restart</button>
    </div>
  </header>

  <div id="overlayTouch">
    <canvas id="c" width="680" height="680"></canvas>
    <!-- touch controls -->
    <div class="directionPad" id="pad">
    <div class="pad-btn up" data-dir="up" data-dir-symbol="â–²"></div>
    <div class="pad-btn down" data-dir="down" data-dir-symbol="â–¼"></div>
    <div class="pad-btn left" data-dir="left" data-dir-symbol="â—€"></div>
    <div class="pad-btn right" data-dir="right" data-dir-symbol="â–¶"></div>
    </div>
  </div>

  <div class="controls">
    <div class="small">Move: Arrow keys / WASD / Touch</div>
    <div style="margin-left:auto" class="small">âš¡ Lightning = eat ghosts â€¢ ðŸ”ª Halving = double points</div>
  </div>

  <footer>Easy Edition â€¢ Longer powerups â€¢ Softer ghosts â€¢ Chomp animation â€¢ Floating scores</footer>
</div>

<script>
/* ============================================================
   Bitcoin Pac â€” Easy Edition
   Upgrades: easier difficulty, 5 lives, longer âš¡, new ðŸ”ª Halving,
   animated chomping, $ pellets, floating scores, better sounds.
   ============================================================ */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const gridSize = 34;
const cols = Math.floor(W / gridSize);
const rows = Math.floor(H / gridSize);
const r = gridSize/2;

const ACCENT = '#ff8a00';
const DOLLAR = '#22c55e';
const GHOSTC = '#e83a3a';
const BG = '#050505';

let scoreEl = document.getElementById('score');
let livesEl = document.getElementById('lives');
let levelEl = document.getElementById('level');
let statusEl = document.getElementById('status');
let restartBtn = document.getElementById('restart');

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function tone(freq, dur, type='sine', vol=0.06){
  try{
    const o=audioCtx.createOscillator(), g=audioCtx.createGain();
    o.type=type; o.frequency.value=freq; g.gain.value=vol;
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); setTimeout(()=>o.stop(), dur*1000);
  }catch(e){}
}
function chord(freqs, dur){
  freqs.forEach((f,i)=>tone(f, dur, i%2?'square':'sine', 0.05));
}

const state = {
  score: 0,
  lives: 5,
  level: 1,
  paused: false,
  powerTimer: 0,       // âš¡ duration in ticks
  halvingTimer: 0,     // ðŸ”ª duration in ticks
  highScore: parseInt(localStorage.getItem('btcPacHigh')||'0'),
  flash: 0             // orange flash overlay frames
};

function updateHUD(){
  scoreEl.textContent = `Score: ${state.score}`;
  livesEl.textContent = `Lives: ${state.lives}`;
  levelEl.textContent = `Level: ${state.level}`;
  if(state.halvingTimer>0 && state.powerTimer>0) statusEl.textContent = `âš¡ + ðŸ”ª active`;
  else if(state.powerTimer>0) statusEl.textContent = `âš¡ POWER`;
  else if(state.halvingTimer>0) statusEl.textContent = `ðŸ”ª HALVING x2`;
  else statusEl.textContent = 'â€”';
}

// floating score popups
const floats = [];
function addFloat(text, x, y, color='#fff'){
  floats.push({text, x, y, color, life:40});
}

// Map: 0 empty, 1 wall, 2 $ pellet, 3 âš¡ power, 4 ðŸ”ª halving
class MapGrid{
  constructor(c,r){
    this.c=c; this.r=r; this.cells=[];
    this.generate();
  }
  generate(){
    for(let y=0;y<this.r;y++){
      this.cells[y]=[];
      for(let x=0;x<this.c;x++){
        if(x===0||y===0||x===this.c-1||y===this.r-1){ this.cells[y][x]=1; continue; }
        // sparser maze than before (easier)
        if((x%2===0 && y%2===0) && Math.random()<0.6) this.cells[y][x]=1;
        else this.cells[y][x]=2; // dollar
      }
    }
    // carve center
    const cx=Math.floor(this.c/2), cy=Math.floor(this.r/2);
    for(let yy=cy-2; yy<=cy+2; yy++) for(let xx=cx-3; xx<=cx+3; xx++) this.cells[yy][xx]=0;
    // corners: power âš¡
    [[1,1],[this.c-2,1],[1,this.r-2],[this.c-2,this.r-2]].forEach(([x,y])=>this.cells[y][x]=3);
    // place 3 halving items ðŸ”ª
    let placed=0;
    while(placed<3){
      const x=1+Math.floor(Math.random()*(this.c-2));
      const y=1+Math.floor(Math.random()*(this.r-2));
      if(this.cells[y][x]===2){ this.cells[y][x]=4; placed++; }
    }
  }
  isWall(x,y){ if(x<0||y<0||x>=this.c||y>=this.r) return true; return this.cells[y][x]===1; }
  eat(x,y){
    const v=this.cells[y][x];
    if(v===2){ this.cells[y][x]=0; return 'dollar'; }
    if(v===3){ this.cells[y][x]=0; return 'power'; }
    if(v===4){ this.cells[y][x]=0; return 'halving'; }
    return null;
  }
  remaining(){
    let n=0; for(let y=0;y<this.r;y++) for(let x=0;x<this.c;x++) if(this.cells[y][x]===2) n++;
    return n;
  }
  draw(ctx){
    ctx.fillStyle=BG; ctx.fillRect(0,0,W,H);
    for(let y=0;y<this.r;y++){
      for(let x=0;x<this.c;x++){
        const v=this.cells[y][x], px=x*gridSize, py=y*gridSize;
        if(v===1){
          ctx.fillStyle='#111'; ctx.fillRect(px+2,py+2,gridSize-4,gridSize-4);
        } else if(v===2){
          // Dollar pellet: draw small $ symbol
          ctx.fillStyle=DOLLAR;
          ctx.font=`${Math.max(12, gridSize*0.5)}px system-ui,Arial`;
          ctx.textAlign='center'; ctx.textBaseline='middle';
          ctx.fillText('$', px+r, py+r+1);
        } else if(v===3){
          // âš¡ Lightning
          ctx.save(); ctx.translate(px+r,py+r);
          ctx.fillStyle='#ffd166';
          ctx.beginPath();
          ctx.moveTo(-8,-7); ctx.lineTo(2,-7); ctx.lineTo(-2,2);
          ctx.lineTo(10,2); ctx.lineTo(2,10); ctx.lineTo(0,3);
          ctx.closePath(); ctx.fill(); ctx.restore();
        } else if(v===4){
          // ðŸ”ª Halving (stylized knife)
          ctx.save(); ctx.translate(px+r,py+r);
          ctx.fillStyle='#b3e5fc';
          ctx.beginPath();
          ctx.moveTo(-10,2); ctx.lineTo(10,-6); ctx.lineTo(10,6); ctx.closePath(); ctx.fill();
          ctx.fillStyle='#cfd8dc'; ctx.fillRect(-10,2,14,6);
          ctx.restore();
        }
      }
    }
  }
}

class Player{
  constructor(){ this.reset(); }
  reset(){
    this.x=Math.floor(cols/2); this.y=rows-3;
    this.dir={x:0,y:0}; this.nextDir={x:0,y:0};
    this.alive=true;
  }
  setDir(dx,dy){ this.nextDir={x:dx,y:dy}; }
  update(){
    if(this.nextDir.x!==this.dir.x || this.nextDir.y!==this.dir.y) this.dir=this.nextDir;
    if(this.dir.x===0 && this.dir.y===0) return;
    const nx=this.x+this.dir.x, ny=this.y+this.dir.y;
    if(!map.isWall(nx,ny)){ this.x=nx; this.y=ny; }
  }
  draw(ctx, t){
    // animated chomping: mouth opens/closes (0..1)
    const mouth = 0.25 + 0.20*Math.abs(Math.sin(t*0.015)); // radians fraction
    const angle = Math.atan2(this.dir.y, this.dir.x) || 0;
    const px=this.x*gridSize+r, py=this.y*gridSize+r;

    ctx.save();
    ctx.translate(px,py);
    ctx.rotate(angle);
    // body
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.fillStyle=ACCENT;
    ctx.arc(0,0, r*0.85, mouth*Math.PI, (2 - mouth)*Math.PI);
    ctx.lineTo(0,0); ctx.fill();

    // inner glow
    ctx.beginPath(); ctx.fillStyle='rgba(255,255,255,0.05)';
    ctx.arc(0,0, r*0.5, 0, Math.PI*2); ctx.fill();

    // â‚¿ glyph
    ctx.fillStyle='#0b0b0b';
    ctx.font = `${r}px system-ui,Arial`; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.rotate(-angle); // keep upright
    ctx.fillText('â‚¿', 0, 3);
    // power ring
    if(state.powerTimer>0){
      ctx.beginPath(); ctx.strokeStyle='rgba(255,255,255,0.18)'; ctx.lineWidth=4;
      ctx.arc(0,0, r*1.15,0,Math.PI*2); ctx.stroke();
    }
    ctx.restore();
  }
}

class Ghost{
  constructor(id,sx,sy,color){
    this.id=id; this.x=sx; this.y=sy;
    this.color=color||GHOSTC; this.dead=false;
    this.prevDir=[0,0];
  }
  update(){
    if(this.dead){
      const cx=Math.floor(cols/2), cy=Math.floor(rows/2);
      if(this.x===cx && this.y===cy){ this.dead=false; return; }
      this.x += Math.sign(cx - this.x);
      this.y += Math.sign(cy - this.y);
      return;
    }
    // Easy AI: mostly random; sometimes greedy toward player.
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    let move;
    if(state.powerTimer>0){
      // frightened: choose step increasing distance
      let best=null,bestD=-Infinity;
      for(const d of dirs){
        const nx=this.x+d[0], ny=this.y+d[1];
        if(!map.isWall(nx,ny)){
          const dist=(nx-player.x)**2+(ny-player.y)**2;
          if(dist>bestD){bestD=dist; best=d;}
        }
      }
      move=best;
    }else{
      if(Math.random()<0.35){
        // random easy move
        const cand = dirs.filter(d=>!map.isWall(this.x+d[0],this.y+d[1]));
        move = cand[Math.floor(Math.random()*cand.length)] || [0,0];
      }else{
        // gentle chase
        let best=null,bestD=Infinity;
        for(const d of dirs){
          const nx=this.x+d[0], ny=this.y+d[1];
          if(!map.isWall(nx,ny)){
            const dist=(nx-player.x)**2+(ny-player.y)**2;
            if(dist<bestD){bestD=dist; best=d;}
          }
        }
        move=best;
      }
    }
    if(move){ this.x+=move[0]; this.y+=move[1]; this.prevDir=move; }
  }
  draw(ctx){
    const px=this.x*gridSize+r, py=this.y*gridSize+r;
    ctx.save();
    ctx.beginPath();
    ctx.fillStyle = (state.powerTimer>0 && !this.dead) ? '#6fa8ff' : this.color;
    ctx.arc(px, py - r*0.12, r*0.8, Math.PI, 0);
    ctx.rect(px - r*0.8, py - 0.12*r, r*1.6, r*0.8);
    ctx.fill();
    // eyes
    ctx.beginPath(); ctx.fillStyle='#fff';
    ctx.ellipse(px - r*0.25, py - r*0.1, r*0.18, r*0.24, 0, 0, Math.PI*2);
    ctx.ellipse(px + r*0.25, py - r*0.1, r*0.18, r*0.24, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath(); ctx.fillStyle='#000';
    ctx.ellipse(px - r*0.25, py - r*0.07, r*0.08, r*0.1, 0, 0, Math.PI*2);
    ctx.ellipse(px + r*0.25, py - r*0.07, r*0.08, r*0.1, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
}

// Globals
let map = new MapGrid(cols,rows);
let player = new Player();
let ghosts = [];
function spawnGhosts(n){
  ghosts=[];
  const cx=Math.floor(cols/2), cy=Math.floor(rows/2);
  for(let i=0;i<n;i++){
    ghosts.push(new Ghost(i, cx + (i%2?i:-i), cy + (i%2?-i:i)));
  }
}

// Easier pacing: slower base tick; speed up slightly every 3 levels.
let baseMsPerTick = 210; // slower than before
let msPerTick = baseMsPerTick;
let lastTime = performance.now(), acc=0;

function resetLevel(){
  map = new MapGrid(cols,rows);
  player.reset();
  spawnGhosts(Math.min(4, 2 + Math.floor((state.level-1)/3))); // ramp every 3 levels
  msPerTick = Math.max(120, baseMsPerTick - 10 * Math.floor((state.level-1)/3));
  state.powerTimer = 0;
  state.halvingTimer = 0;
  updateHUD();
}

function startNewGame(){
  state.score=0; state.lives=5; state.level=1;
  resetLevel(); updateHUD();
}

// Points (doubled during halving)
function addScore(base, px, py){
  const mult = state.halvingTimer>0 ? 2 : 1;
  const gained = base * mult;
  state.score += gained;
  addFloat(`+${gained}`, px, py, mult>1 ? '#b3e5fc' : '#fff');
  updateHUD();
}

// collisions
function handleCollisions(){
  // eat cell
  const eaten = map.eat(player.x, player.y);
  const px = player.x*gridSize+r, py = player.y*gridSize+r;
  if(eaten==='dollar'){ addScore(10, px, py); tone(880,0.05,'sine',0.05); }
  else if(eaten==='power'){
    addScore(50, px, py);
    state.powerTimer = 60; // ~10 seconds (60 ticks * ~0.16s each) given pacing
    state.flash = 6; // short flash frames
    chord([600,900], 0.10);
  } else if(eaten==='halving'){
    addScore(100, px, py);
    state.halvingTimer = 120; // ~20 seconds
    chord([500,750,1000], 0.12);
    addFloat('HALVING x2!', px, py-8, '#b3e5fc');
  }

  // ghosts
  for(const g of ghosts){
    if(g.x===player.x && g.y===player.y){
      if(g.dead) continue;
      if(state.powerTimer>0){
        g.dead=true; addScore(200, px, py); tone(160,0.12,'square',0.08);
      }else{
        state.lives--; updateHUD();
        // death tone
        tone(200,0.15,'square',0.12); setTimeout(()=>tone(100,0.12,'square',0.05),170);
        if(state.lives<=0){
          if(state.score>state.highScore){ state.highScore=state.score; localStorage.setItem('btcPacHigh', String(state.highScore)); }
          alert(`Game Over â€” Score: ${state.score} â€¢ High: ${state.highScore}`);
          startNewGame(); return;
        }else{
          // soft respawn
          player.reset(); spawnGhosts(Math.min(4, 2 + Math.floor((state.level-1)/3)));
          state.powerTimer=0; // clear
          return;
        }
      }
    }
  }

  // level clear
  if(map.remaining()===0){
    state.level++;
    // level bonus grows a bit
    addScore(500 + state.level*50, px, py);
    chord([700,900,1200],0.14);
    resetLevel();
  }
}

// draw floats
function drawFloats(){
  for(let i=floats.length-1; i>=0; i--){
    const f=floats[i];
    ctx.globalAlpha = Math.max(0, f.life/40);
    ctx.fillStyle=f.color; ctx.font='16px system-ui,Arial'; ctx.textAlign='center';
    ctx.fillText(f.text, f.x, f.y - (40 - f.life)*0.8);
    ctx.globalAlpha=1;
    f.life--; if(f.life<=0) floats.splice(i,1);
  }
}

// tick/render
function tick(){
  // player/ghost update
  player.update();
  ghosts.forEach(g=>g.update());
  if(state.powerTimer>0) state.powerTimer--;
  if(state.halvingTimer>0) state.halvingTimer--;
  if(state.flash>0) state.flash--;
  handleCollisions();
}

function render(t){
  map.draw(ctx);
  ghosts.forEach(g=>g.draw(ctx));
  player.draw(ctx, t);
  drawFloats();
  // flash overlay on powerup pickup
  if(state.flash>0){
    ctx.fillStyle='rgba(255,138,0,0.15)';
    ctx.fillRect(0,0,W,H);
  }
}

function loop(now){
  const dt = now - lastTime; lastTime = now; acc += dt;
  while(acc >= msPerTick){ tick(); acc -= msPerTick; }
  render(now);
  requestAnimationFrame(loop);
}

// Controls
const keyMap = {
  ArrowUp:[0,-1], ArrowDown:[0,1], ArrowLeft:[-1,0], ArrowRight:[1,0],
  w:[0,-1], s:[0,1], a:[-1,0], d:[1,0]
};
window.addEventListener('keydown', e=>{
  const k=e.key; if(keyMap[k]){ player.setDir(...keyMap[k]); e.preventDefault(); }
  if(k==='p') state.paused = !state.paused;
  if(k===' '){ // tiny dash
    const nx=player.x+player.dir.x, ny=player.y+player.dir.y;
    if(!map.isWall(nx,ny)){ player.x=nx; player.y=ny; tone(1000,0.02); }
  }
});
// touch
document.getElementById('pad').addEventListener('pointerdown', e=>{
  const d=e.target.getAttribute('data-dir'); if(!d) return;
  const m={up:[0,-1],down:[0,1],left:[-1,0],right:[1,0]}; player.setDir(...m[d]);
});

// Restart
restartBtn.addEventListener('click', ()=>{ if(confirm('Restart game?')) startNewGame(); });

// Init
startNewGame();
lastTime = performance.now(); requestAnimationFrame(loop);

// Always show d-pad on mobile devices
(function(){
  const pad=document.getElementById('pad');
  // Simple detection
  const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
  if(isMobile){
    pad.style.display = 'block';
  } else {
    pad.style.display = 'none';
  }
})();
</script>
</body>
</html>


